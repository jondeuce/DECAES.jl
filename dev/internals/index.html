<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · DECAES.jl</title><meta name="title" content="Internals · DECAES.jl"/><meta property="og:title" content="Internals · DECAES.jl"/><meta property="twitter:title" content="Internals · DECAES.jl"/><meta name="description" content="Documentation for DECAES.jl."/><meta property="og:description" content="Documentation for DECAES.jl."/><meta property="twitter:description" content="Documentation for DECAES.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DECAES.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DECAES.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../cli/">Command Line Interface</a></li><li><a class="tocitem" href="../ref/">API Reference</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#main"><span><code>NNLS</code> submodule</span></a></li><li><a class="tocitem" href="#main-2"><span><code>NormalHermiteSplines</code> submodule</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jondeuce/DECAES.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jondeuce/DECAES.jl/blob/master/docs/src/internals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><h2 id="main"><a class="docs-heading-anchor" href="#main"><code>NNLS</code> submodule</a><a id="main-1"></a><a class="docs-heading-anchor-permalink" href="#main" title="Permalink"></a></h2><p>This submodule is derived from a <a href="https://github.com/jondeuce/NonNegLeastSquares.jl/blob/a122bf7acb498efcaf140b719133691e7c4cd03d/src/nnls.jl">fork of the <code>NonNegLeastSquares.jl</code> package</a>.</p><ul><li><a href="#DECAES.NNLS.apply_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T"><code>DECAES.NNLS.apply_householder!</code></a></li><li><a href="#DECAES.NNLS.compute_dual!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64, Int64}} where T"><code>DECAES.NNLS.compute_dual!</code></a></li><li><a href="#DECAES.NNLS.construct_householder!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>DECAES.NNLS.construct_householder!</code></a></li><li><a href="#DECAES.NNLS.nnls-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Vararg{Any}}} where T"><code>DECAES.NNLS.nnls</code></a></li><li><a href="#DECAES.NNLS.orthogonal_rotmat-Union{Tuple{T}, Tuple{T, T}} where T"><code>DECAES.NNLS.orthogonal_rotmat</code></a></li><li><a href="#DECAES.NNLS.solve_triangular_system!-Union{Tuple{transp}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64, Val{transp}}} where {T, transp}"><code>DECAES.NNLS.solve_triangular_system!</code></a></li><li><a href="#DECAES.NNLS.unsafe_nnls!-Union{Tuple{DECAES.NNLS.NNLSWorkspace{T}}, Tuple{T}} where T"><code>DECAES.NNLS.unsafe_nnls!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.apply_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T" href="#DECAES.NNLS.apply_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T"><code>DECAES.NNLS.apply_householder!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION Q = I + U*(U**T)/B</p><p>The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book &quot;SOLVING LEAST SQUARES PROBLEMS&quot;, Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L236-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.compute_dual!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64, Int64}} where T" href="#DECAES.NNLS.compute_dual!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64, Int64}} where T"><code>DECAES.NNLS.compute_dual!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L339-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.construct_householder!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#DECAES.NNLS.construct_householder!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>DECAES.NNLS.construct_householder!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION Q = I + U*(U**T)/B</p><p>The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book &quot;SOLVING LEAST SQUARES PROBLEMS&quot;, Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L203-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.nnls-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Vararg{Any}}} where T" href="#DECAES.NNLS.nnls-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Vararg{Any}}} where T"><code>DECAES.NNLS.nnls</code></a> — <span class="docstring-category">Method</span></header><section><div><p>x = nnls(A, b; ...)</p><p>Solves non-negative least-squares problem by the active set method of Lawson &amp; Hanson (1974).</p><p>Optional arguments:</p><pre><code class="nohighlight hljs">- max_iter: maximum number of iterations (counts inner loop iterations)</code></pre><p>References:</p><pre><code class="nohighlight hljs">- Lawson, C.L. and R.J. Hanson, Solving Least-Squares Problems
- Prentice-Hall, Chapter 23, p. 161, 1974</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L156-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.orthogonal_rotmat-Union{Tuple{T}, Tuple{T, T}} where T" href="#DECAES.NNLS.orthogonal_rotmat-Union{Tuple{T}, Tuple{T, T}} where T"><code>DECAES.NNLS.orthogonal_rotmat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>COMPUTE ORTHOGONAL ROTATION MATRIX The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book &quot;SOLVING LEAST SQUARES PROBLEMS&quot;, Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.</p><pre><code class="nohighlight hljs">COMPUTE MATRIX  (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2))
                (-S,C)         (-S,C)(B)   (   0          )
COMPUTE SIG = SQRT(A**2+B**2)
    SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT
    SIG MAY BE IN THE SAME LOCATION AS A OR B .</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L374-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.solve_triangular_system!-Union{Tuple{transp}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64, Val{transp}}} where {T, transp}" href="#DECAES.NNLS.solve_triangular_system!-Union{Tuple{transp}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64, Val{transp}}} where {T, transp}"><code>DECAES.NNLS.solve_triangular_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book &quot;SOLVING LEAST SQUARES PROBLEMS&quot;, Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L401-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NNLS.unsafe_nnls!-Union{Tuple{DECAES.NNLS.NNLSWorkspace{T}}, Tuple{T}} where T" href="#DECAES.NNLS.unsafe_nnls!-Union{Tuple{DECAES.NNLS.NNLSWorkspace{T}}, Tuple{T}} where T"><code>DECAES.NNLS.unsafe_nnls!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Algorithm NNLS: NONNEGATIVE LEAST SQUARES</p><p>The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book &quot;SOLVING LEAST SQUARES PROBLEMS&quot;, Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.</p><p>GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B, COMPUTE AN N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM A * X = B SUBJECT TO X .GE. 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NNLS.jl#L458-L470">source</a></section></article><h2 id="main-2"><a class="docs-heading-anchor" href="#main-2"><code>NormalHermiteSplines</code> submodule</a><a class="docs-heading-anchor-permalink" href="#main-2" title="Permalink"></a></h2><p>This submodule is derived from a <a href="https://github.com/jondeuce/NormalHermiteSplines.jl">fork of the <code>NormalHermiteSplines.jl</code> package</a>.</p><ul><li><a href="#DECAES.NormalHermiteSplines.NormalSpline"><code>DECAES.NormalHermiteSplines.NormalSpline</code></a></li><li><a href="#DECAES.NormalHermiteSplines.RK_H0"><code>DECAES.NormalHermiteSplines.RK_H0</code></a></li><li><a href="#DECAES.NormalHermiteSplines.RK_H1"><code>DECAES.NormalHermiteSplines.RK_H1</code></a></li><li><a href="#DECAES.NormalHermiteSplines.RK_H2"><code>DECAES.NormalHermiteSplines.RK_H2</code></a></li><li><a href="#DECAES.NormalHermiteSplines._estimate_cond-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization, Any}} where T"><code>DECAES.NormalHermiteSplines._estimate_cond</code></a></li><li><a href="#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.construct</code></a></li><li><a href="#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.construct</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_accuracy-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_accuracy</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_cond-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel}"><code>DECAES.NormalHermiteSplines.estimate_cond</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractMatrix{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate_derivative-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_derivative</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate_gradient-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_gradient</code></a></li><li><a href="#DECAES.NormalHermiteSplines.evaluate_one-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_one</code></a></li><li><a href="#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.get_cond</code></a></li><li><a href="#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.get_cond</code></a></li><li><a href="#DECAES.NormalHermiteSplines.get_epsilon-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.get_epsilon</code></a></li><li><a href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.interpolate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.interpolate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.interpolate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, NTuple{4, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.interpolate</code></a></li><li><a href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.prepare</code></a></li><li><a href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.prepare</code></a></li><li><a href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.prepare</code></a></li><li><a href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.prepare</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.NormalSpline" href="#DECAES.NormalHermiteSplines.NormalSpline"><code>DECAES.NormalHermiteSplines.NormalSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct NormalSpline{n, T &lt;: Real, RK &lt;: ReproducingKernel_0} &lt;: AbstractNormalSpline{n,T,RK}</code></p><p>Define a structure containing full information of a normal spline</p><p><strong>Fields</strong></p><ul><li><code>_kernel</code>: a reproducing kernel spline was built with</li><li><code>_nodes</code>: transformed function value nodes</li><li><code>_values</code>: function values at interpolation nodes</li><li><code>_d_nodes</code>: transformed function directional derivative nodes</li><li><code>_d_dirs</code>: normalized derivative directions</li><li><code>_d_values</code>: function directional derivative values</li><li><code>_mu</code>: spline coefficients</li><li><code>_rhs</code>: right-hand side of the problem <code>gram * mu = rhs</code></li><li><code>_gram</code>: Gram matrix of the problem <code>gram * mu = rhs</code></li><li><code>_chol</code>: Cholesky factorization of the Gram matrix</li><li><code>_cond</code>: estimation of the Gram matrix condition number</li><li><code>_min_bound</code>: minimal bounds of the original node locations area</li><li><code>_max_bound</code>: maximal bounds of the original node locations area</li><li><code>_scale</code>: factor of transforming the original node locations into unit hypercube</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L629-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.RK_H0" href="#DECAES.NormalHermiteSplines.RK_H0"><code>DECAES.NormalHermiteSplines.RK_H0</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H0{T} &lt;: ReproducingKernel_0</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 1/2}_ε (R^n)$</span> (&#39;Basic Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L53-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.RK_H1" href="#DECAES.NormalHermiteSplines.RK_H1"><code>DECAES.NormalHermiteSplines.RK_H1</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H1{T} &lt;: ReproducingKernel_1</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 3/2}_ε (R^n)$</span> (&#39;Linear Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (1 + \varepsilon |\xi  - \eta|) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.RK_H2" href="#DECAES.NormalHermiteSplines.RK_H2"><code>DECAES.NormalHermiteSplines.RK_H2</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H2{T} &lt;: ReproducingKernel_2</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 5/2}_ε (R^n)$</span> (&#39;Quadratic Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (3 + 3\varepsilon |\xi  - \eta| + \varepsilon ^2 |\xi - \eta| ^2 ) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L106-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines._estimate_cond-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization, Any}} where T" href="#DECAES.NormalHermiteSplines._estimate_cond-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization, Any}} where T"><code>DECAES.NormalHermiteSplines._estimate_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get estimation of the Gram matrix condition number Brás, C.P., Hager, W.W. &amp; Júdice, J.J. An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP 20, 791–809 (2012). https://link.springer.com/article/10.1007/s11750-010-0161-9</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1002-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.construct</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>construct(spline::AbstractNormalSpline{n,T,RK}, values::AbstractVector{T}, d_values::AbstractVector{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Construct the spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_values</code>: function directional derivative values at <code>d_nodes</code> nodes.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function to interpolate the data to required points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1420-L1434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.construct</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>construct(spline::AbstractNormalSpline{n,T,RK}, values::AbstractVector{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Construct the spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function to interpolate the data to required points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1256-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_accuracy-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.estimate_accuracy-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_accuracy(spline::AbstractNormalSpline{n,T,RK}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Assess accuracy of interpolation results by analyzing residuals.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>construct</code> or <code>interpolate</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>An estimation of the number of significant digits in the interpolation result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1737-L1749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_cond-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel}" href="#DECAES.NormalHermiteSplines.estimate_cond-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel}"><code>DECAES.NormalHermiteSplines.estimate_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_cond(spline::AbstractNormalSpline{n,T,RK}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Get an estimation of the Gram matrix condition number. It needs the <code>spline</code> object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>An estimation of the Gram matrix condition number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1719-L1732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_epsilon(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Get the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>Estimation of <code>ε</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1659-L1680">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_epsilon(nodes::AbstractVector{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the 1D spline is being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>Estimation of <code>ε</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1817-L1835">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_epsilon(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivative nodes. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>Estimation of <code>ε</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1688-L1711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>estimate_epsilon(nodes::AbstractVector{T}, d_nodes::AbstractVector{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the 1D spline is being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>d_nodes</code>: The function derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>Estimation of <code>ε</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1840-L1858">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate(spline::AbstractNormalSpline{1,T,RK}, point::T) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline value is evaluating.</li></ul><p><strong>Returns</strong></p><ul><li>Spline value at the <code>point</code> location.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1545-L1558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractMatrix{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractMatrix{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate(spline::AbstractNormalSpline{n,T,RK}, points::AbstractMatrix{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline values at the locations defined in <code>points</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline: the</code>NormalSpline<code>object returned by</code>interpolate<code>or</code>construct` function.</li><li><code>points</code>: locations at which spline values are evaluating. This should be an <code>n×m</code> matrix, where <code>n</code> is dimension of the sampled space and <code>m</code> is the number of locations where spline values are evaluating. It means that each column in the matrix defines one location.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code> of the spline values at the locations defined in <code>points</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1304-L1320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate(spline::AbstractNormalSpline{n,T,RK}, points::AbstractVector{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline values/value at the <code>points</code> locations.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>points</code>: locations at which spline values are evaluating. This should be a vector of size <code>m</code> where <code>m</code> is the number of evaluating points.</li></ul><p><strong>Returns</strong></p><ul><li>Spline value at the <code>point</code> location.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1526-L1540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate_derivative-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate_derivative-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate_derivative(spline::AbstractNormalSpline{1,T,RK}, point::T) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline derivative at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline derivative is evaluating.</li></ul><p>Note: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p><strong>Returns</strong></p><ul><li>The spline derivative value at the <code>point</code> location.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1564-L1579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate_gradient-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate_gradient-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate_gradient(spline::AbstractNormalSpline{n,T,RK}, point::AbstractVector{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate gradient of the spline at the location defined in <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which gradient value is evaluating. This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Note: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code> - gradient of the spline at the location defined in <code>point</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1358-L1374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.evaluate_one-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.evaluate_one-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1&lt;:Real, T2&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.evaluate_one</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evaluate_one(spline::AbstractNormalSpline{n,T,RK}, point::AbstractVector{T}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline value is evaluating. This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p><strong>Returns</strong></p><ul><li>The spline value at the location defined in <code>point</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1335-L1349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.get_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_cond(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires <span>$O(N^3)$</span> operations.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivatives nodes. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes.</li><li><code>d_dirs</code>: Directions of the function directional derivatives. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>A value of the Gram matrix spectral condition number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1781-L1807">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.get_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_cond(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires <span>$O(N^3)$</span> operations.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>A value of the Gram matrix spectral condition number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1754-L1773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.get_epsilon-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.get_epsilon-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.get_epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_epsilon(spline::AbstractNormalSpline{n,T,RK}) where {n, T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Get the &#39;scaling parameter&#39; of Bessel Potential space the spline was built in.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>The &#39;scaling parameter&#39; <code>ε</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1642-L1654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, NTuple{4, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, NTuple{4, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>interpolate(nodes::AbstractVector{T}, values::AbstractVector{T}, d_nodes::AbstractVector{T}, d_values::AbstractVector{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare and construct the 1D interpolating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes. This should be an <code>n₁</code> vector where <code>n₁</code> is the number of function value nodes.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_nodes</code>: The function derivatives nodes. This should be an <code>n₂</code> vector where <code>n₂</code> is the number of function derivatives nodes.</li><li><code>d_values</code>: function derivative values at <code>d_nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1613-L1634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>interpolate(nodes::AbstractMatrix{T}, values::AbstractVector{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, d_values::AbstractVector{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare and construct the spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_nodes</code>: The function directional derivative nodes. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes.</li><li><code>d_dirs</code>: Directions of the function directional derivatives. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>d_values</code>: function directional derivative values at <code>d_nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1439-L1467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>interpolate(nodes::AbstractMatrix{T}, values::AbstractVector{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1274-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>interpolate(nodes::AbstractVector{T}, values::AbstractVector{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the 1D spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes. This should be an <code>n₁</code> vector where <code>n₁</code> is the number of function value nodes.</li><li><code>values</code>: function values at <code>n₁</code> interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1502-L1521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>prepare(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function in order to complete the spline initialization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1228-L1248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}" href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_0}"><code>DECAES.NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>prepare(nodes::AbstractVector{T}, kernel::RK = RK_H0()) where {T &lt;: Real, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes. This should be an <code>n₁</code> vector where <code>n₁</code> is the number of function value nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H0</code> if the spline is constructing as a continuous function, <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function in order to complete the spline initialization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1478-L1497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>prepare(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes. This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₁</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivatives nodes. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes.</li><li><code>d_dirs</code>: Directions of the function directional derivatives. This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and <code>n₂</code> is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function in order to complete the spline initialization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1385-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}" href="#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T&lt;:Real, RK&lt;:DECAES.NormalHermiteSplines.ReproducingKernel_1}"><code>DECAES.NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>prepare(nodes::AbstractVector{T}, d_nodes::AbstractVector{T}, kernel::RK = RK_H1()) where {T &lt;: Real, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the 1D interpolating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes. This should be an <code>n₁</code> vector where <code>n₁</code> is the number of function value nodes.</li><li><code>d_nodes</code>: The function derivatives nodes. This should be an <code>n₂</code> vector where <code>n₂</code> is the number of function derivatives nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: <code>RK_H1</code> if the spline is constructing as a differentiable function, <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p><strong>Returns</strong></p><ul><li>The partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function in order to complete the spline initialization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L1587-L1607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky!-Union{Tuple{fill_parent}, Tuple{T}, Tuple{DECAES.NormalHermiteSplines.ElasticCholesky{T, AType} where AType&lt;:AbstractMatrix{T}, Int64, AbstractVector{T}, Val{fill_parent}}} where {T, fill_parent}" href="#LinearAlgebra.cholesky!-Union{Tuple{fill_parent}, Tuple{T}, Tuple{DECAES.NormalHermiteSplines.ElasticCholesky{T, AType} where AType&lt;:AbstractMatrix{T}, Int64, AbstractVector{T}, Val{fill_parent}}} where {T, fill_parent}"><code>LinearAlgebra.cholesky!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.cholesky!(C::ElasticCholesky, v::AbstractVector{T}) where {T}</code></pre><p>Update the Cholesky factorization <code>C</code> as if the column <code>v</code> (and by symmetry, the corresponding row <code>vᵀ</code>) were inserted into the underlying matrix <code>A</code>. Specifically, let <code>L</code> be the lower-triangular cholesky factor of <code>A</code> such that <code>A = LLᵀ</code>, and let <code>v = [d; γ]</code> such that the new matrix <code>A⁺</code> is given by</p><pre><code class="nohighlight hljs">A⁺ = [A  d]
     [dᵀ γ].</code></pre><p>Then, the corresponding updated cholesky factor <code>L⁺</code> of <code>⁺</code> is:</p><pre><code class="nohighlight hljs">L⁺ = [L  0]
     [eᵀ α]</code></pre><p>where <code>e = L⁻¹d</code>, <code>α = √τ</code>, and <code>τ = γ - e⋅e &gt; 0</code>. If <code>τ ≤ 0</code>, then <code>A⁺</code> is not positive definite.</p><p>See: https://igorkohan.github.io/NormalHermiteSplines.jl/dev/Normal-Splines-Method/#Algorithms-for-updating-Cholesky-factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/DECAES.jl/blob/2435b03aa1c4ed755f760aeeef2d37e905871829/src/NormalHermiteSplines.jl#L517-L540">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ref/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 9 April 2024 23:33">Tuesday 9 April 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
