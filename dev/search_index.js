var documenterSearchIndex = {"docs":
[{"location":"cli/#Command-Line-Interface","page":"Command Line Interface","title":"Command Line Interface","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"DECAES provides a command line interface (CLI) for calling the main analysis functions: T2mapSEcorr for computing T_2-distributions, and T2partSEcorr for running T_2-parts analysis on the resulting T_2-distributions for computing measures such as the myelin water fraction.","category":"page"},{"location":"cli/#Using-the-CLI","page":"Command Line Interface","title":"Using the CLI","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"There are two equivalent ways to use the command line interface (CLI), assuming DECAES is already installed:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"1. (Recommended) decaes launcher: Use the script ~/.julia/bin/decaes which comes with DECAES:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"$ decaes <COMMAND LINE ARGS>","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nAdd ~/.julia/bin to your PATH to avoid writing the full path ~/.julia/bin/decaes.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"2. Julia -e flag: Call the DECAES CLI from Julia directly using the -e (for \"evaluate\") flag:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"$ julia --project=@decaes --threads=auto -e 'using DECAES; main()' -- <COMMAND LINE ARGS>","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"The decaes launcher is in fact just a thin wrapper script around a command like this one.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nThe flag --threads=auto enables parallel processing, which is critical for maximizing DECAES performance.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Either way of calling the CLI forwards the arguments <COMMAND LINE ARGS> to the entrypoint function main. Available command line arguments are detailed in the Arguments section.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"For the remainder of this section, we will make use of the decaes launcher.","category":"page"},{"location":"cli/#File-types","page":"Command Line Interface","title":"File types","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Input files must be one of the following file types:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"NIfTI file with extension .nii, or gzip compressed NIfTI file with extension .nii.gz. See NIfTI.jl for more information.\nMATLAB file with extension .mat. Note: .mat files saved in the oldest format v4 are not supported, but all newer formats (v6, v7, and v7.3) are supported. See MAT.jl for more information.\nPhilips PAR/REC file pair with extensions .par and .rec (or .PAR and .REC).\nPhilips XML/REC file pair with extensions .xml and .rec (or .XML and .REC).","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"All output files are saved as .mat files in format v7.3.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nIf your data is in DICOM format, the freely available dcm2niix tool is able to convert DICOM files into NIfTI format","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nInput files are interpreted as 4D arrays (or 3D arrays for mask files) when loaded; ensure that the underlying data is stored with the first three dimensions as (row, column, slice), and the last dimension as echo (or T_2 bin, or omitted for mask files)\nImages read from NIfTI and PAR/XML/REC files are coerced into the appropriate dimension; errors or unexpected behaviour may occur if the data is not stored with the correct dimensions\nMATLAB files are searched for arrays with the appropriate dimension; the first such array that is found is used, otherwise an error will occur. Multiple 3D/4D arrays should not be stored in the same .mat file)","category":"page"},{"location":"cli/#Arguments","page":"Command Line Interface","title":"Arguments","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Available command line arguments are broken into four categories:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Positional arguments: these are the input files. Input files are typically placed at the beginning of <COMMAND LINE ARGS>.\nOptional arguments: settings governing the analysis pipeline. See below for details.\nT2mapSEcorr/T2partSEcorr arguments: settings for computing the T_2-distribution and subsequent T_2-parts analysis. Required arguments are listed first; see below for the full parameter list, and see T2mapSEcorr and T2partSEcorr for parameter descriptions. Note: if no default is shown, the parameter is unused by default.\nB1 correction and stimulated echo correction: settings for controlling B1 correction and stimulated echo correction. These settings typically need not be modified. However, the following options are noteworthy: --SetFlipAngle allows for prescribing a fixed flip angle for all voxels instead of estimating the flip angle per-voxel; and --B1map allows for passing B1 maps (units of degrees) directly, replacing the flip angle estimation step.\nAdditional save options: optional additional output maps\nBET arguments: settings for governing automatic brain mask generation using the BET brain extraction tool; see below for details.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"using DECAES # hide\nDECAES.ArgParse.show_help(DECAES.CLI_SETTINGS; exit_when_done = false) # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nIf desired, the T_2-distribution computation and the T_2-parts analysis may be performed separately:When the --T2map flag is passed, or both --T2map and --T2part flags are passed, input image arrays should be 4D with data as (row, column, slice, echo)\nWhen only the --T2part flag is passed, input image arrays should be 4D with data as (row, column, slice, T_2 bin)","category":"page"},{"location":"cli/#Outputs","page":"Command Line Interface","title":"Outputs","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"DECAES will produce up to five output files, each with the input filename (without suffix) used as a prefix. For example, if the input file is called image.nii, the possible output files are:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"image.t2dist.mat: MATLAB file containing the 4D array of T_2-distributions (produced when --T2map flag is passed)\nimage.t2maps.mat: MATLAB file containing T_2-distribution property maps and NNLS fit parameters; see T2mapSEcorr (produced when --T2map flag is passed)\nimage.t2parts.mat: MATLAB file containing T_2-parts analysis results such as the MWF; see T2partSEcorr (produced when --T2part flag is passed)\nimage.log: Log file containing the console output\nimage.settings.txt: Copy of settings file which was named settings.txt (produced when passing settings as a file)","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"If the --dry flag is passed, none of the above files will be produced.","category":"page"},{"location":"cli/#Examples","page":"Command Line Interface","title":"Examples","text":"","category":"section"},{"location":"cli/#defaultoptions","page":"Command Line Interface","title":"Default options","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Suppose you have a multi spin-echo image file image.nii which you would like to perform T_2 analysis on. We can call T2mapSEcorr and T2partSEcorr on the file image.nii using the decaes launcher. We pass the required arguments with the appropriate flags and leave the remaining parameters at default values:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image.nii --T2map --T2part --TE 10e-3 --nT2 40 --T2Range 10e-3 2.0 --SPWin 10e-3 40e-3 --MPWin 40e-3 200.0e-3 --Reg lcurve\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"After a few seconds, the script should begin running with the following messages appearing as the script progresses (note that real images will take longer to process than this toy example):","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"callmain(imfile, \"--T2map\", \"--T2part\", \"--TE\", \"10e-3\", \"--nT2\", \"40\", \"--T2Range\", \"10e-3\", \"2.0\", \"--SPWin\", \"10e-3\", \"40e-3\", \"--MPWin\", \"40e-3\", \"200.0e-3\", \"--Reg\", \"lcurve\") # hide","category":"page"},{"location":"cli/#settingsfiles","page":"Command Line Interface","title":"Settings files","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"As there are several required parameters, it is convenient to store settings for DECAES in a settings file. Using the same options from the previous section, we create a file settings.txt with the following contents:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"/path/to/image.nii\n--T2map\n--T2part\n--TE\n10e-3\n--nT2\n40\n--T2Range\n10e-3\n2.0\n--SPWin\n10e-3\n40e-3\n--MPWin\n40e-3\n200.0e-3\n--Reg\nlcurve","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"If this file is located at /path/to/settings.txt, simply prefix the filepath with the @ character to have the file contents read into the main function:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes @/path/to/settings.txt\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nThe use of settings files is highly recommended for both reproducibility and for self-documentation. The input settings file will be automatically copied into the output folder for each processed image, with the image filename prepended. In this case, for example, the copied settings file would be called image.settings.txt\nOnly one flag or value is allowed per line within a settings file. Flags which require multiple inputs (e.g. --T2Range above) must use one line for each input\nThe extension of the settings file is ignored; .txt is arbitrary in this example\nThough not strictly necessary, using full input- and output paths in the settings file is convenient. This way, one doesn't rely on relative paths and can call e.g. decaes @/path/to/settings.txt from any directory","category":"page"},{"location":"cli/#nondefault","page":"Command Line Interface","title":"Default settings files","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Suppose you have a default settings file default.txt, similar to the settings.txt file in the above section. Settings in default.txt can be individually overridden. For example, if we are interested in changing the number of T_2 bins nT2 to 60, but leaving all other parameters the same, run the following:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes @/path/to/default.txt --nT2 60\") # hide","category":"page"},{"location":"cli/#multiinput","page":"Command Line Interface","title":"Multiple input files","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Multiple input files (possibly of different file types) can be passed in the obvious way:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image1.nii image2.mat image3.nii.gz image4.par <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Equivalently, place multiple image paths at the top of your settings file, with each path on a new line.","category":"page"},{"location":"cli/#outfolder","page":"Command Line Interface","title":"Specify output folder","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"By default, output files are saved in the same location as the corresponding input file. If you'd like to save them in a different folder, you can use the -o or --output flag:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image.nii --output /path/to/output/folder/ <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"The requested output folder will be created if it does not already exist.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Equivalently, add --output and /path/to/output/folder/ as consecutive lines in your settings file.","category":"page"},{"location":"cli/#passmasks","page":"Command Line Interface","title":"Passing image masks","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Image masks can be passed into DECAES using the -m or --mask flag:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image.nii --mask /path/to/mask.nii <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"The mask file is loaded and applied to the input image via elementwise multiplication over the spatial dimensions, e.g. the mask is applied to each echo of a 4D multi-echo input image.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"If multiple image files are passed, multiple corresponding mask files can be passed, too:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image1.nii image2.mat --mask /path/to/mask1.mat /path/to/mask2.nii.gz <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Equivalently, add --mask, /path/to/mask1.mat, /path/to/mask2.mat, ...  as consecutive lines in your settings file.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nIf input images have been manually masked such that they are zero outside regions of interest, a mask need not be passed. The --Threshold parameter of T2mapSEcorr controls a first echo intensity cutoff threshold (default value 0.0), below which voxels are automatically skipped during processing","category":"page"},{"location":"cli/#bet","page":"Command Line Interface","title":"Automatic brain masking with BET","text":"","category":"section"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"The BET brain extraction tool from the FSL library of analysis tools can be used to automatically generate a brain mask prior to analysis. Only voxels within the generated brain mask will be processed, greatly reducing analysis time. To use BET, pass the --bet flag:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image.nii --bet <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"If bet is not on your system path, you can pass the path to the bet binary with the --betpath flag. Additionally, you can pass arguments to bet with the --betargs flag:","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"println(\"\\$ decaes image.nii --bet --betpath /path/to/bet --betargs -m,-n <COMMAND LINE ARGS>\") # hide","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Note that bet arguments must be passed as a single string to --betargs, separated by commas or spaces, as shown above.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"Equivalently, add --bet, --betpath, /path/to/bet, --betargs, -m,-n as consecutive lines in your settings file.","category":"page"},{"location":"cli/","page":"Command Line Interface","title":"Command Line Interface","text":"note: Note\nIf a mask file is passed using the --mask flag, the --bet flag will be ignored and the mask file will be used","category":"page"},{"location":"ref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"ref/","page":"API Reference","title":"API Reference","text":"Pages = [\"ref.md\"]","category":"page"},{"location":"ref/#t2map","page":"API Reference","title":"T_2-distribution mapping","text":"","category":"section"},{"location":"ref/#DECAES.T2mapOptions","page":"API Reference","title":"DECAES.T2mapOptions","text":"T2mapOptions(; kwargs...)\nT2mapOptions(image::Array{T,4}; kwargs...) where {T}\n\nOptions structure for T2mapSEcorr. This struct collects keyword arguments passed to T2mapSEcorr, performs checks on parameter types and values, and assigns default values to unspecified parameters.\n\nArguments\n\nlegacy::Bool: Perform T2-mapping using legacy algorithms. Default: false\nThreaded::Bool: Perform T2-mapping using multiple threads. Default: Threads.nthreads() > 1\nMatrixSize::Tuple{Int64, Int64, Int64}: Size of first 3 dimensions of input 4D image. This argument has no default, but is inferred automatically as size(image)[1:3] when calling T2mapSEcorr(image; kwargs...).\nnTE::Int64: Number of echoes in input signal. This argument is has no default, but is inferred automatically as size(image, 4) when calling T2mapSEcorr(image; kwargs...).\nTE::Real: Interecho spacing (Units: seconds). This argument has no default.\nnT2::Int64: Number of T2 times to estimate in the multi-exponential analysis. This argument has no default.\nT2Range::Tuple{T, T} where T<:Real: Tuple of min and max T2 values (Units: seconds). This argument has no default.\nT1::Real: Assumed value of T1 (Units: seconds). Default: 1.0\nThreshold::Real: First echo intensity cutoff for empty voxels. Default: 0.0\nMinRefAngle::Real: Minimum refocusing angle for flip angle optimization (Units: degrees). Default: 50.0\nnRefAngles::Int64: During flip angle optimization, goodness of fit is checked for up to nRefAngles angles in the range [MinRefAngle, 180]. The optimal angle is then determined through interpolation from these samples. Default: if !legacy     64 else     8 end\nnRefAnglesMin::Int64: Initial number of angles to check during flip angle optimization before refinement near likely optima. Setting nRefAnglesMin equal to nRefAngles forces all angles to be checked. Default: if !legacy     min(5, nRefAngles) else     nRefAngles end\nReg::String: Regularization routine to use. One of \"none\", \"lcurve\", \"gcv\", \"chi2\", or \"mdp\", representing no regularization, the L-Curve method, the Generalized Cross-Validation method, Chi2Factor-based Tikhonov regularization, or the Morozov discrepancy principle, respectively.\nChi2Factor::Union{Nothing, T} where T<:Real: Constraint on chi^2 used for regularization when Reg == \"chi2\". Default: nothing\nNoiseLevel::Union{Nothing, T} where T<:Real: Estimate of the homoscedastic noise level b_i - hatb_i, where b is the unknown true signal and hatb is the measured corrupted signal. For Gaussian noise, this is the standard deviation. Default: nothing\nRefConAngle::Real: Refocusing pulse control angle (Units: degrees). Default: 180.0\nSetFlipAngle::Union{Nothing, T} where T<:Real: Instead of optimizing flip angle, use SetFlipAngle for all voxels (Units: degrees). Default: nothing\nSaveResidualNorm::Bool: Boolean flag to include a 3D array of the ell^2-norms of the residuals from the NNLS fits in the output maps dictionary. Default: false\nSaveDecayCurve::Bool: Boolean flag to include a 4D array of the time domain decay curves resulting from the NNLS fits in the output maps dictionary. Default: false\nSaveRegParam::Bool: Boolean flag to include 3D arrays of the regularization parameters mu and resulting chi^2-factors in the output maps dictionary. Default: false\nSaveNNLSBasis::Bool: Boolean flag to include a 5D (or 2D if SetFlipAngle is used) array of NNLS basis matrices in the output maps dictionary. Default: false\nSilent::Bool: Suppress printing to the console. Default: false\n\nnote: Note\nThe 5D array that is saved when SaveNNLSBasis is set to true has dimensions MatrixSize x nTE x nT2, and therefore is typically extremely large. If the flip angle is fixed via SetFlipAngle, however, this is not an issue as only the unique nTE x nT2 2D basis matrix is saved.\n\nSee also:\n\nT2mapSEcorr\n\n\n\n\n\n","category":"type"},{"location":"ref/#DECAES.T2mapSEcorr","page":"API Reference","title":"DECAES.T2mapSEcorr","text":"T2mapSEcorr(image::Array{T,4}; <keyword arguments>)\nT2mapSEcorr(image::Array{T,4}, opts::T2mapOptions{T})\n\nUses nonnegative least squares (NNLS) to compute T2 distributions in the presence of stimulated echos by optimizing the refocusing pulse flip angle. Records parameter maps and T2 distributions for further partitioning.\n\nArguments\n\nimage: 4D array with intensity data as (row, column, slice, echo)\nA series of optional keyword argument settings which will be used to construct a T2mapOptions struct internally, or a T2mapOptions struct directly\n\nOutputs\n\nmaps: dictionary containing parameter maps with the following fields:\nDefault Fields\n\"echotimes\"     Echo times of time signal (length nTE 1D array)\n\"t2times\"       T2 times corresponding to T2-distributions (length nT2 1D array)\n\"refangleset\"   Refocusing angles used during flip angle optimization (length nRefAngles 1D array by default; scalar if SetFlipAngle is used)\n\"decaybasisset\" Decay basis sets corresponding to \"refangleset\" (nTE x nT2 x nRefAngles 3D array by default; nTE x nT2 2D array if SetFlipAngle is used)\n\"gdn\":          Map of general density = sum(T2distribution) (MatrixSize 3D array)\n\"ggm\":          Map of general geometric mean of T2-distribution (MatrixSize 3D array)\n\"gva\":          Map of general variance (MatrixSize 3D array)\n\"fnr\":          Map of fit to noise ratio = gdn / √(sum(residuals.^2) / (nTE-1)) (MatrixSize 3D array)\n\"snr\":          Map of signal to noise ratio = maximum(signal) / std(residuals) (MatrixSize 3D array)\n\"alpha\":        Map of optimized refocusing pulse flip angle (MatrixSize 3D array)\nOptional Fields\n\"resnorm\":      ell^2-norm of NNLS fit residuals; see SaveResidualNorm option (MatrixSize 3D array)\n\"decaycurve\":   Signal decay curve resulting from NNLS fit; see SaveDecayCurve option (MatrixSize x nTE 4D array)\n\"mu\":           Regularization parameter used during from NNLS fit; see SaveRegParam option (MatrixSize 3D array)\n\"chi2factor\":   chi^2 increase factor relative to unregularized NNLS fit; see SaveRegParam option (MatrixSize 3D array)\n\"decaybasis\":   Decay bases resulting from flip angle optimization; see SaveNNLSBasis option (MatrixSize x nTE x nT2 5D array, or nTE x nT2 2D array if SetFlipAngle is used)\ndistributions: T2-distribution array with data as (row, column, slice, T2 amplitude) (MatrixSize x nT2 4D array)\n\nExamples\n\njulia> image = DECAES.mock_image(; MatrixSize = (100, 100, 1), nTE = 48); # mock image with size 100x100x1x48\n\njulia> maps, dist = T2mapSEcorr(image; TE = 10e-3, nT2 = 40, T2Range = (10e-3, 2.0), Reg = \"lcurve\", Silent = true); # compute the T2-maps and T2-distribution\n\njulia> maps\nDict{String, Any} with 10 entries:\n  \"echotimes\"     => [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08,…\n  \"t2times\"       => [0.01, 0.0114551, 0.013122, 0.0150315, 0.0172188…\n  \"refangleset\"   => [50.0, 54.1935, 58.3871, 62.5806, 66.7742, 70.96…\n  \"gdn\"           => [1.26381 1.27882 … 1.2463 1.25091; 1.29848 1.243…\n  \"fnr\"           => [379.9 437.541 … 446.88 386.396; 485.27 360.591 …\n  \"alpha\"         => [165.461 166.286 … 164.614 164.389; 163.735 164.…\n  \"gva\"           => [0.691794 0.440231 … 0.0490302 0.1253; 0.849798 …\n  \"ggm\"           => [0.0663333 0.0705959 … 0.056455 0.0576729; 0.053…\n  \"snr\"           => [312.773 364.031 … 363.463 313.372; 372.631 313.…\n  \"decaybasisset\" => [0.0277684 0.0315296 … 0.0750511 0.0751058; 0.04…\n\nSee also:\n\nT2partSEcorr\nlsqnonneg\nlsqnonneg_tikh\nlsqnonneg_lcurve\nlsqnonneg_gcv\nlsqnonneg_chi2\nlsqnonneg_mdp\nEPGdecaycurve\n\n\n\n\n\n","category":"function"},{"location":"ref/#t2part","page":"API Reference","title":"T_2-parts and the myelin water fraction","text":"","category":"section"},{"location":"ref/#DECAES.T2partOptions","page":"API Reference","title":"DECAES.T2partOptions","text":"T2partOptions(; kwargs...)\nT2partOptions(t2dist::Array{T,4}; kwargs...) where {T}\n\nOptions structure for T2partSEcorr. This struct collects keyword arguments passed to T2partSEcorr, performs checks on parameter types and values, and assigns default values to unspecified parameters.\n\nArguments\n\nlegacy::Bool: Calculate T2-parts using legacy algorithms. Default: false\nThreaded::Bool: Perform T2-parts using multiple threads. Default: Threads.nthreads() > 1\nMatrixSize::Tuple{Int64, Int64, Int64}: Size of first 3 dimensions of input 4D T2 distribution. This argument is has no default, but is inferred automatically as size(t2dist)[1:3] when calling T2partSEcorr(t2dist; kwargs...).\nnT2::Int64: Number of T2 times to use. This argument has no default.\nT2Range::Tuple{T, T} where T<:Real: Tuple of min and max T2 values (Units: seconds). This argument has no default.\nSPWin::Tuple{T, T} where T<:Real: Tuple of min and max T2 values of the short peak window (Units: seconds). This argument has no default.\nMPWin::Tuple{T, T} where T<:Real: Tuple of min and max T2 values of the middle peak window (Units: seconds). This argument has no default.\nSigmoid::Union{Nothing, T} where T<:Real: Apply sigmoidal weighting to the upper limit of the short peak window in order to smooth the hard small peak window cutoff time. Sigmoid is the delta-T2 parameter, which is the distance in seconds on either side of the SPWin upper limit where the sigmoid curve reaches 10% and 90% (Units: seconds). Default: nothing\nSilent::Bool: Suppress printing to the console. Default: false\n\nSee also:\n\nT2partSEcorr\n\n\n\n\n\n","category":"type"},{"location":"ref/#DECAES.T2partSEcorr","page":"API Reference","title":"DECAES.T2partSEcorr","text":"T2partSEcorr(T2distributions::Array{T,4}; <keyword arguments>)\nT2partSEcorr(T2distributions::Array{T,4}, opts::T2partOptions{T})\n\nAnalyzes T2 distributions produced by T2mapSEcorr to produce data maps of a series of parameters.\n\nArguments\n\nT2distributions: 4D array with data as (row, column, slice, T2 amplitude)\nA series of optional keyword argument settings which will be used to construct a T2partOptions struct internally, or a T2partOptions struct directly\n\nOuputs\n\nmaps: a dictionary containing the following 3D data maps as fields:\n\"sfr\": small pool fraction, e.g. myelin water fraction (MatrixSize 3D array)\n\"sgm\": small pool geometric mean T2 (MatrixSize 3D array)\n\"mfr\": medium pool fraction, e.g. intra/extracellular water fraction (MatrixSize 3D array)\n\"mgm\": medium pool geometric mean T2 (MatrixSize 3D array)\n\nExamples\n\njulia> dist = DECAES.mock_t2dist(; MatrixSize = (100, 100, 1), nT2 = 40); # mock distribution with size 100x100x1x40\n\njulia> maps = T2partSEcorr(dist; T2Range = (10e-3, 2.0), SPWin = (10e-3, 25e-3), MPWin = (25e-3, 200e-3), Silent = true); # compute T2-parts maps\n\njulia> maps\nDict{String, Any} with 4 entries:\n  \"sgm\" => [0.014202 0.0106354 … 0.0125409 0.0114035; 0.0119888 0.0110439 …\n  \"mfr\" => [0.86938 0.886926 … 0.901487 0.835647; 0.840086 0.890914 … 0.88…\n  \"sfr\" => [0.13062 0.112288 … 0.0985133 0.163075; 0.159914 0.109086 … 0.1…\n  \"mgm\" => [0.0871951 0.0481156 … 0.0612596 0.0475037; 0.0629991 0.0738904…\n\nSee also:\n\nT2mapSEcorr\n\n\n\n\n\n","category":"function"},{"location":"ref/#main","page":"API Reference","title":"Main entrypoint function","text":"","category":"section"},{"location":"ref/#DECAES.main","page":"API Reference","title":"DECAES.main","text":"main(command_line_args::Vector{String} = ARGS)\n\nEntry point function for command line interface, parsing the command line arguments ARGS and subsequently calling one or both of T2mapSEcorr and T2partSEcorr with the parsed settings. See the Arguments section for available options.\n\nSee also:\n\nT2mapSEcorr\nT2partSEcorr\n\n\n\n\n\n","category":"function"},{"location":"ref/#nnls","page":"API Reference","title":"NNLS analysis","text":"","category":"section"},{"location":"ref/#DECAES.lsqnonneg","page":"API Reference","title":"DECAES.lsqnonneg","text":"lsqnonneg(A::AbstractMatrix, b::AbstractVector)\n\nCompute the nonnegative least-squares (NNLS) solution X of the problem:\n\nX = undersetx ge 0operatornameargmin Ax - b_2^2\n\nArguments\n\nA::AbstractMatrix: Left hand side matrix acting on x\nb::AbstractVector: Right hand side vector\n\nOutputs\n\nX::AbstractVector: NNLS solution\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lsqnonneg_tikh","page":"API Reference","title":"DECAES.lsqnonneg_tikh","text":"lsqnonneg_tikh(A::AbstractMatrix, b::AbstractVector, μ::Real)\n\nCompute the Tikhonov-regularized nonnegative least-squares (NNLS) solution X_mu of the problem:\n\nX_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 x_2^2\n\nArguments\n\nA::AbstractMatrix: Left hand side matrix acting on x\nb::AbstractVector: Right hand side vector\nμ::Real: Regularization parameter\n\nOutputs\n\nX::AbstractVector: NNLS solution\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lsqnonneg_lcurve","page":"API Reference","title":"DECAES.lsqnonneg_lcurve","text":"lsqnonneg_lcurve(A::AbstractMatrix, b::AbstractVector)\n\nCompute the Tikhonov-regularized nonnegative least-squares (NNLS) solution X_mu of the problem:\n\nX_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 L x_2^2\n\nwhere L is the identity matrix, and mu is chosen by locating the corner of the \"L-curve\"[1]. Details of L-curve theory can be found in Hansen (1992)[2].\n\nArguments\n\nA::AbstractMatrix: Decay basis matrix\nb::AbstractVector: Decay curve data\n\nOutputs\n\nX::AbstractVector: Regularized NNLS solution\nmu::Real: Resulting regularization parameter mu\nchi2::Real: Resulting increase in residual norm relative to the unregularized mu = 0 solution\n\nReferences\n\nA. Cultrera and L. Callegaro, \"A simple algorithm to find the L-curve corner in the regularization of ill-posed inverse problems\". IOPSciNotes, vol. 1, no. 2, p. 025004, Aug. 2020, https://doi.org/10.1088/2633-1357/abad0d.\nHansen, P.C., 1992. Analysis of Discrete Ill-Posed Problems by Means of the L-Curve. SIAM Review, 34(4), 561-580, https://doi.org/10.1137/1034115.\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lsqnonneg_gcv","page":"API Reference","title":"DECAES.lsqnonneg_gcv","text":"lsqnonneg_gcv(A::AbstractMatrix, b::AbstractVector)\n\nCompute the Tikhonov-regularized nonnegative least-squares (NNLS) solution X_mu of the problem:\n\nX_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 L x_2^2\n\nwhere L is the identity matrix, and mu is chosen via the Generalized Cross-Validation (GCV) method:\n\nmu = undersetnu ge 0operatornameargmin fracAX_nu - b_2^2mathcalT(nu)^2\n\nwhere mathcalT(mu) is the \"degrees of freedom\" of the regularized system\n\nmathcalT(mu) = operatornametr(I - A (A^T A + mu^2 L^T L) A^T)\n\nDetails of the GCV method can be found in Hansen (1992)[1].\n\nArguments\n\nA::AbstractMatrix: Decay basis matrix\nb::AbstractVector: Decay curve data\n\nOutputs\n\nX::AbstractVector: Regularized NNLS solution\nmu::Real: Resulting regularization parameter mu\nchi2::Real: Resulting increase in residual norm relative to the unregularized mu = 0 solution\n\nReferences\n\nHansen, P.C., 1992. Analysis of Discrete Ill-Posed Problems by Means of the L-Curve. SIAM Review, 34(4), 561-580, https://doi.org/10.1137/1034115.\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lsqnonneg_chi2","page":"API Reference","title":"DECAES.lsqnonneg_chi2","text":"lsqnonneg_chi2(A::AbstractMatrix, b::AbstractVector, chi2_target::Real)\n\nCompute the Tikhonov-regularized nonnegative least-squares (NNLS) solution X_mu of the problem:\n\nX_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 x_2^2\n\nwhere mu is determined by solving:\n\nchi^2(mu) = fracAX_mu - b_2^2AX_0 - b_2^2 = chi^2_mathrmtarget\n\nThat is, mu is chosen such that the squared residual norm of the regularized problem is chi2_target times larger than the squared residual norm of the unregularized problem.\n\nArguments\n\nA::AbstractMatrix: Decay basis matrix\nb::AbstractVector: Decay curve data\nchi2_target::Real: Target chi^2(mu); typically a small value, e.g. 1.02 representing a 2% increase\n\nOutputs\n\nX::AbstractVector: Regularized NNLS solution\nmu::Real: Resulting regularization parameter mu\nchi2::Real: Resulting chi^2(mu), which should be approximately equal to chi2_target\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lsqnonneg_mdp","page":"API Reference","title":"DECAES.lsqnonneg_mdp","text":"lsqnonneg_mdp(A::AbstractMatrix, b::AbstractVector, δ::Real)\n\nCompute the Tikhonov-regularized nonnegative least-squares (NNLS) solution X_mu of the problem:\n\nX_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 x_2^2\n\nwhere mu is chosen using Morozov's Discrepency Principle (MDP)[1,2]:\n\nmu = operatornamesup left nu ge 0  AX_nu - b le delta right\n\nThat is, mu is maximized subject to the constraint that the residual norm of the regularized problem is at most delta[1].\n\nArguments\n\nA::AbstractMatrix: Decay basis matrix\nb::AbstractVector: Decay curve data\nδ::Real: Upper bound on regularized residual norm\n\nOutputs\n\nX::AbstractVector: Regularized NNLS solution\nmu::Real: Resulting regularization parameter mu\nchi2::Real: Resulting increase in residual norm relative to the unregularized mu = 0 solution\n\nReferences\n\nMorozov VA. Methods for Solving Incorrectly Posed Problems. Springer Science & Business Media, 2012.\nClason C, Kaltenbacher B, Resmerita E. Regularization of Ill-Posed Problems with Non-negative Solutions. In: Bauschke HH, Burachik RS, Luke DR (eds) Splitting Algorithms, Modern Operator Theory, and Applications. Cham: Springer International Publishing, pp. 113–135.\n\n\n\n\n\n","category":"function"},{"location":"ref/#DECAES.lcurve_corner","page":"API Reference","title":"DECAES.lcurve_corner","text":"lcurve_corner(f, xlow, xhigh)\n\nFind the corner of the L-curve via curvature maximization using a modified version of Algorithm 1 from Cultrera and Callegaro (2020)[1].\n\nReferences\n\nA. Cultrera and L. Callegaro, \"A simple algorithm to find the L-curve corner in the regularization of ill-posed inverse problems\". IOPSciNotes, vol. 1, no. 2, p. 025004, Aug. 2020, https://doi.org/10.1088/2633-1357/abad0d.\n\n\n\n\n\n","category":"function"},{"location":"ref/#epg","page":"API Reference","title":"Extended phase graph algorithm","text":"","category":"section"},{"location":"ref/#DECAES.EPGdecaycurve","page":"API Reference","title":"DECAES.EPGdecaycurve","text":"EPGdecaycurve(ETL::Int, α::Real, TE::Real, T2::Real, T1::Real, β::Real)\n\nComputes the normalized echo decay curve for a multi spin echo sequence using the extended phase graph algorithm using the given input parameters.\n\nThe sequence of flip angles used is slight generalization of the standard 90 degree excitation pulse followed by 180 degree pulse train. Here, the sequence used is A*90, A*180, A*β, A*β, ... where A = α/180 accounts for B1 inhomogeneities. Equivalently, the pulse sequence can be written as α/2, α, α * (β/180), α * (β/180), .... Note that if α = β = 180, we recover the standard 90, 180, 180, ... pulse sequence.\n\nArguments\n\nETL::Int:   echo train length, i.e. number of echos\nα::Real:    angle of refocusing pulses (Units: degrees)\nTE::Real:   inter-echo time (Units: seconds)\nT2::Real:   transverse relaxation time (Units: seconds)\nT1::Real:   longitudinal relaxation time (Units: seconds)\nβ::Real:    value of Refocusing Pulse Control Angle (Units: degrees)\n\nOutputs\n\ndecay_curve::AbstractVector: normalized echo decay curve with length ETL\n\n\n\n\n\n","category":"function"},{"location":"#DEcomposition-and-Component-Analysis-of-Exponential-Signals-(DECAES)","page":"Home","title":"DEcomposition and Component Analysis of Exponential Signals (DECAES)","text":"","category":"section"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"t2map.md\",\n    \"t2part.md\",\n    \"cli.md\",\n    \"ref.md\",\n    \"internals.md\",\n]\nDepth = 2","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DECAES provides tools for decomposing multi-exponential signals which arise from multi spin-echo magnetic resonance imaging (MRI) scans into exponential components. The main decomposition method used is an inverse Laplace transform-based technique which involves solving the regularized nonnegative least squares (NNLS) inverse problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"X_mu = undersetx ge 0operatornameargmin Ax - b_2^2 + mu^2 x_2^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"where b is the signal magnitude data, A is a matrix of exponential decay bases, and mu is a regularization parameter. A is constructed using the extended phase graph algorithm with stimulated echo correction. The columns of A are exponential bases with differing characteristic T_2 decay times T_2 j.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output X_mu is the spectrum of (nonnegative) exponential decay amplitudes. Amplitude X_mu j of the spectrum X_mu is therefore interpreted physically as the amount of the signal b which decays with time constant T_2 j. For this reason, the spectrum X_mu is commonly referred to as the T_2 distribution. DECAES provides methods for computing T_2-distributions.","category":"page"},{"location":"#installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Julia v1.9 or later you can install DECAES as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project=@decaes -e 'import Pkg; Pkg.add(\"DECAES\"); Pkg.build(\"DECAES\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will add DECAES.jl to a named Julia project environment separate from your global environment, and build the decaes launcher script at ~/.julia/bin for running DECAES from the command line.","category":"page"},{"location":"#updating","page":"Home","title":"Updating DECAES","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DECAES can similarly be updated to the latest version as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project=@decaes -e 'import Pkg; Pkg.update(\"DECAES\"); Pkg.build(\"DECAES\")'","category":"page"},{"location":"#Myelin-water-imaging","page":"Home","title":"Myelin water imaging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Myelin water imaging (MWI) is an MRI technique used to visualize the myelin water contained within the sheaths of myelinated axons within the body, such as within the brain's white matter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Through analysing T_2-distributions computed from multi spin-echo MRI scans, one can separate the contribution due to the myelin water from the intra- and extra-cellular water and compute the myelin water fraction (MWF). The MWF describes the fraction of water trapped between myelin lipid bilayers relative to the total water in the region. DECAES provides methods for computing the MWF.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MWI was pioneered at the University of British Columbia by Alex MacKay and Ken Whittal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basics of myelin water imaging:","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://doi.org/10.1002/mrm.1910310614\nhttps://doi.org/10.1016/0022-2364(89)90011-5\nhttps://doi.org/10.1016/j.neuroimage.2012.06.064\nhttps://doi.org/10.1002/mrm.23157","category":"page"},{"location":"","page":"Home","title":"Home","text":"Validation of myelin water imaging:","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://doi.org/10.1016/j.neuroimage.2007.12.008\nhttps://doi.org/10.1016/j.neuroimage.2017.03.065\nhttps://doi.org/10.1016/j.neuroimage.2019.05.042","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some applications of myelin water imaging:","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://doi.org/10.1177/1352458517723717\nhttps://doi.org/10.1038/s41598-018-33112-8\nhttps://doi.org/10.1371/journal.pone.0150215","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Porting to Julia was done by Jonathan Doucette (email: jdoucette@physics.ubc.ca) in November 2019. This work was funded by NSERC (016-05371) and CIHR (RN382474-418628) under PI Alexander Rauscher at the University of British Columbia\nChristian Kames (email: ckames@physics.ubc.ca) contributed to optimizing the Julia port for both speed and memory efficiency, as well as writing the PAR/XML/REC file reader used internally\nOriginal MATLAB code was written by Thomas Prasloski (email: tprasloski@gmail.com). Modifications to the MATLAB code were made by Vanessa Wiggermann to enable processing on various MATLAB versions in February 2019. The Julia port is based on this modified version","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Z Med Phys)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use DECAES in your research, please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{DECAES.jl-2020,\n  title = {{{DECAES}} - {{DEcomposition}} and {{Component Analysis}} of {{Exponential Signals}}},\n  author = {Doucette, Jonathan and Kames, Christian and Rauscher, Alexander},\n  year = {2020},\n  month = may,\n  issn = {1876-4436},\n  doi = {10.1016/j.zemedi.2020.04.001},\n  journal = {Zeitschrift Fur Medizinische Physik},\n  keywords = {Brain,Luminal Water Imaging,MRI,Myelin Water Imaging,Prostate},\n  language = {eng},\n  pmid = {32451148}\n}","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#main","page":"Internals","title":"NNLS submodule","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This submodule is derived from a fork of the NonNegLeastSquares.jl package.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [DECAES.NNLS]","category":"page"},{"location":"internals/#DECAES.NNLS.apply_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T","page":"Internals","title":"DECAES.NNLS.apply_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.compute_dual!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64, Int64}} where T","page":"Internals","title":"DECAES.NNLS.compute_dual!","text":"COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W().\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.construct_householder!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Internals","title":"DECAES.NNLS.construct_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.nnls-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Vararg{Any}}} where T","page":"Internals","title":"DECAES.NNLS.nnls","text":"x = nnls(A, b; ...)\n\nSolves non-negative least-squares problem by the active set method of Lawson & Hanson (1974).\n\nOptional arguments:\n\n- max_iter: maximum number of iterations (counts inner loop iterations)\n\nReferences:\n\n- Lawson, C.L. and R.J. Hanson, Solving Least-Squares Problems\n- Prentice-Hall, Chapter 23, p. 161, 1974\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.orthogonal_rotmat-Union{Tuple{T}, Tuple{T, T}} where T","page":"Internals","title":"DECAES.NNLS.orthogonal_rotmat","text":"COMPUTE ORTHOGONAL ROTATION MATRIX The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nCOMPUTE MATRIX  (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2))\n                (-S,C)         (-S,C)(B)   (   0          )\nCOMPUTE SIG = SQRT(A**2+B**2)\n    SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT\n    SIG MAY BE IN THE SAME LOCATION AS A OR B .\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.solve_triangular_system!-Union{Tuple{transp}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64, Val{transp}}} where {T, transp}","page":"Internals","title":"DECAES.NNLS.solve_triangular_system!","text":"The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NNLS.unsafe_nnls!-Union{Tuple{DECAES.NNLS.NNLSWorkspace{T}}, Tuple{T}} where T","page":"Internals","title":"DECAES.NNLS.unsafe_nnls!","text":"Algorithm NNLS: NONNEGATIVE LEAST SQUARES\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nGIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B, COMPUTE AN N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM A * X = B SUBJECT TO X .GE. 0\n\n\n\n\n\n","category":"method"},{"location":"internals/#main-2","page":"Internals","title":"NormalHermiteSplines submodule","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This submodule is derived from a fork of the NormalHermiteSplines.jl package.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [DECAES.NormalHermiteSplines]","category":"page"},{"location":"internals/#DECAES.NormalHermiteSplines.NormalSpline","page":"Internals","title":"DECAES.NormalHermiteSplines.NormalSpline","text":"struct NormalSpline{n, T <: Real, RK <: ReproducingKernel_0} <: AbstractNormalSpline{n,T,RK}\n\nDefine a structure containing full information of a normal spline\n\nFields\n\n_kernel: a reproducing kernel spline was built with\n_nodes: transformed function value nodes\n_values: function values at interpolation nodes\n_d_nodes: transformed function directional derivative nodes\n_d_dirs: normalized derivative directions\n_d_values: function directional derivative values\n_mu: spline coefficients\n_rhs: right-hand side of the problem gram * mu = rhs\n_gram: Gram matrix of the problem gram * mu = rhs\n_chol: Cholesky factorization of the Gram matrix\n_cond: estimation of the Gram matrix condition number\n_min_bound: minimal bounds of the original node locations area\n_max_bound: maximal bounds of the original node locations area\n_scale: factor of transforming the original node locations into unit hypercube\n\n\n\n\n\n","category":"type"},{"location":"internals/#DECAES.NormalHermiteSplines.RK_H0","page":"Internals","title":"DECAES.NormalHermiteSplines.RK_H0","text":"struct RK_H0{T} <: ReproducingKernel_0\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 12_ε (R^n) ('Basic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"internals/#DECAES.NormalHermiteSplines.RK_H1","page":"Internals","title":"DECAES.NormalHermiteSplines.RK_H1","text":"struct RK_H1{T} <: ReproducingKernel_1\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 32_ε (R^n) ('Linear Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (1 + varepsilon xi  - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"internals/#DECAES.NormalHermiteSplines.RK_H2","page":"Internals","title":"DECAES.NormalHermiteSplines.RK_H2","text":"struct RK_H2{T} <: ReproducingKernel_2\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 52_ε (R^n) ('Quadratic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (3 + 3varepsilon xi  - eta + varepsilon ^2 xi - eta ^2 )  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"internals/#DECAES.NormalHermiteSplines._estimate_cond-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization}, Tuple{AbstractMatrix{T}, LinearAlgebra.Factorization, Any}} where T","page":"Internals","title":"DECAES.NormalHermiteSplines._estimate_cond","text":"Get estimation of the Gram matrix condition number Brás, C.P., Hager, W.W. & Júdice, J.J. An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP 20, 791–809 (2012). https://link.springer.com/article/10.1007/s11750-010-0161-9\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}, AbstractVector{T}}} where {n, T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.construct","text":"construct(spline::AbstractNormalSpline{n,T,RK}, values::AbstractVector{T}, d_values::AbstractVector{T}) where {n, T <: Real, RK <: ReproducingKernel_1}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\nd_values: function directional derivative values at d_nodes nodes.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function to interpolate the data to required points.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.construct-Union{Tuple{RK}, Tuple{T}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}, AbstractVector{T}}} where {n, T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.construct","text":"construct(spline::AbstractNormalSpline{n,T,RK}, values::AbstractVector{T}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function to interpolate the data to required points.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_accuracy-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_accuracy","text":"estimate_accuracy(spline::AbstractNormalSpline{n,T,RK}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nAssess accuracy of interpolation results by analyzing residuals.\n\nArguments\n\nspline: the NormalSpline object returned by construct or interpolate function.\n\nReturns\n\nAn estimation of the number of significant digits in the interpolation result.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_cond-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_cond","text":"estimate_cond(spline::AbstractNormalSpline{n,T,RK}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nGet an estimation of the Gram matrix condition number. It needs the spline object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturns\n\nAn estimation of the Gram matrix condition number.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nGet the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nEstimation of ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::AbstractVector{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the 1D spline is being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nEstimation of ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nd_nodes: The function directional derivative nodes. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nEstimation of ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.estimate_epsilon-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::AbstractVector{T}, d_nodes::AbstractVector{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the 1D spline is being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nEstimation of ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate","text":"evaluate(spline::AbstractNormalSpline{1,T,RK}, point::T) where {T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.\n\nReturns\n\nSpline value at the point location.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractMatrix{T2}}} where {n, T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate","text":"evaluate(spline::AbstractNormalSpline{n,T,RK}, points::AbstractMatrix{T}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate the spline values at the locations defined in points.\n\nArguments\n\nspline: theNormalSplineobject returned byinterpolateorconstruct` function.\npoints: locations at which spline values are evaluating. This should be an n×m matrix, where n is dimension of the sampled space and m is the number of locations where spline values are evaluating. It means that each column in the matrix defines one location.\n\nReturns\n\nVector{T} of the spline values at the locations defined in points.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate","text":"evaluate(spline::AbstractNormalSpline{n,T,RK}, points::AbstractVector{T}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline values/value at the points locations.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoints: locations at which spline values are evaluating. This should be a vector of size m where m is the number of evaluating points.\n\nReturns\n\nSpline value at the point location.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate_derivative-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{1, T1, RK}, T2}} where {T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate_derivative","text":"evaluate_derivative(spline::AbstractNormalSpline{1,T,RK}, point::T) where {T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline derivative at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline derivative is evaluating.\n\nNote: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturns\n\nThe spline derivative value at the point location.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate_gradient-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate_gradient","text":"evaluate_gradient(spline::AbstractNormalSpline{n,T,RK}, point::AbstractVector{T}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate gradient of the spline at the location defined in point.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which gradient value is evaluating. This should be a vector of size n, where n is dimension of the sampled space.\n\nNote: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturns\n\nVector{T} - gradient of the spline at the location defined in point.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.evaluate_one-Union{Tuple{RK}, Tuple{T2}, Tuple{T1}, Tuple{n}, Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T1, RK}, AbstractVector{T2}}} where {n, T1<:Real, T2<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.evaluate_one","text":"evaluate_one(spline::AbstractNormalSpline{n,T,RK}, point::AbstractVector{T}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nEvaluate the spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating. This should be a vector of size n, where n is dimension of the sampled space.\n\nReturns\n\nThe spline value at the location defined in point.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.get_cond","text":"get_cond(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes.\nd_dirs: Directions of the function directional derivatives. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nA value of the Gram matrix spectral condition number.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.get_cond-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.get_cond","text":"get_cond(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nA value of the Gram matrix spectral condition number.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.get_epsilon-Union{Tuple{DECAES.NormalHermiteSplines.AbstractNormalSpline{n, T, RK}}, Tuple{RK}, Tuple{T}, Tuple{n}} where {n, T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.get_epsilon","text":"get_epsilon(spline::AbstractNormalSpline{n,T,RK}) where {n, T <: Real, RK <: ReproducingKernel_0}\n\nGet the 'scaling parameter' of Bessel Potential space the spline was built in.\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturns\n\nThe 'scaling parameter' ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, NTuple{4, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.interpolate","text":"interpolate(nodes::AbstractVector{T}, values::AbstractVector{T}, d_nodes::AbstractVector{T}, d_values::AbstractVector{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nPrepare and construct the 1D interpolating normal spline.\n\nArguments\n\nnodes: function value interpolation nodes. This should be an n₁ vector where n₁ is the number of function value nodes.\nvalues: function values at nodes nodes.\nd_nodes: The function derivatives nodes. This should be an n₂ vector where n₂ is the number of function derivatives nodes.\nd_values: function derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.interpolate","text":"interpolate(nodes::AbstractMatrix{T}, values::AbstractVector{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, d_values::AbstractVector{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nd_nodes: The function directional derivative nodes. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes.\nd_dirs: Directions of the function directional derivatives. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.\nd_values: function directional derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}, Tuple{AbstractMatrix{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.interpolate","text":"interpolate(nodes::AbstractMatrix{T}, values::AbstractVector{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.interpolate-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.interpolate","text":"interpolate(nodes::AbstractVector{T}, values::AbstractVector{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: function value interpolation nodes. This should be an n₁ vector where n₁ is the number of function value nodes.\nvalues: function values at n₁ interpolation nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractMatrix{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.prepare","text":"prepare(nodes::AbstractMatrix{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe partly initialized NormalSpline object that must be passed to construct function in order to complete the spline initialization.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.prepare-Union{Tuple{AbstractVector{T}}, Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_0}","page":"Internals","title":"DECAES.NormalHermiteSplines.prepare","text":"prepare(nodes::AbstractVector{T}, kernel::RK = RK_H0()) where {T <: Real, RK <: ReproducingKernel_0}\n\nPrepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: function value interpolation nodes. This should be an n₁ vector where n₁ is the number of function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H0 if the spline is constructing as a continuous function, RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe partly initialized NormalSpline object that must be passed to construct function in order to complete the spline initialization.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.prepare","text":"prepare(nodes::AbstractMatrix{T}, d_nodes::AbstractMatrix{T}, d_dirs::AbstractMatrix{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes. This should be an n×n_1 matrix, where n is dimension of the sampled space and n₁ is the number of function value nodes. It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes.\nd_dirs: Directions of the function directional derivatives. This should be an n×n_2 matrix, where n is dimension of the sampled space and n₂ is the number of function directional derivative nodes. It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe partly initialized NormalSpline object that must be passed to construct function in order to complete the spline initialization.\n\n\n\n\n\n","category":"method"},{"location":"internals/#DECAES.NormalHermiteSplines.prepare-Union{Tuple{RK}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, RK}} where {T<:Real, RK<:DECAES.NormalHermiteSplines.ReproducingKernel_1}","page":"Internals","title":"DECAES.NormalHermiteSplines.prepare","text":"prepare(nodes::AbstractVector{T}, d_nodes::AbstractVector{T}, kernel::RK = RK_H1()) where {T <: Real, RK <: ReproducingKernel_1}\n\nPrepare the 1D interpolating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: function value interpolation nodes. This should be an n₁ vector where n₁ is the number of function value nodes.\nd_nodes: The function derivatives nodes. This should be an n₂ vector where n₂ is the number of function derivatives nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in. It must be a struct object of the following type: RK_H1 if the spline is constructing as a differentiable function, RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturns\n\nThe partly initialized NormalSpline object that must be passed to construct function in order to complete the spline initialization.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LinearAlgebra.cholesky!-Union{Tuple{fill_parent}, Tuple{T}, Tuple{DECAES.NormalHermiteSplines.ElasticCholesky{T, AType} where AType<:AbstractMatrix{T}, Int64, AbstractVector{T}, Val{fill_parent}}} where {T, fill_parent}","page":"Internals","title":"LinearAlgebra.cholesky!","text":"LinearAlgebra.cholesky!(C::ElasticCholesky, v::AbstractVector{T}) where {T}\n\nUpdate the Cholesky factorization C as if the column v (and by symmetry, the corresponding row vᵀ) were inserted into the underlying matrix A. Specifically, let L be the lower-triangular cholesky factor of A such that A = LLᵀ, and let v = [d; γ] such that the new matrix A⁺ is given by\n\nA⁺ = [A  d]\n     [dᵀ γ].\n\nThen, the corresponding updated cholesky factor L⁺ of ⁺ is:\n\nL⁺ = [L  0]\n     [eᵀ α]\n\nwhere e = L⁻¹d, α = √τ, and τ = γ - e⋅e > 0. If τ ≤ 0, then A⁺ is not positive definite.\n\nSee: https://igorkohan.github.io/NormalHermiteSplines.jl/dev/Normal-Splines-Method/#Algorithms-for-updating-Cholesky-factorization\n\n\n\n\n\n","category":"method"}]
}
